/*
 * avr128db_clock_tune.cpp
 *
 * Board: Curiosity NANO AVR128DB48
 *
 * Created: 12.05.2023 18:34:10
 */

#define F_CPU 16000000UL

#include <avr/io.h>
#include <avr/xmega.h>
#include <util/delay.h>

static_assert(1 == 1, "test");

uint16_t reset_counter __attribute__ ((section (".noinit")));

inline void inc3(auto & cntr) { ++cntr; }


int main(void) {
    // setup clock so delays are correct
    _PROTECTED_WRITE(CLKCTRL.OSCHFCTRLA, CLKCTRL_FREQSEL_16M_gc
                     | CLKCTRL_AUTOTUNE_bm
    );



    //_PROTECTED_WRITE(CLKCTRL.MCLKCTRLB, CLKCTRL_PEN_bm | CLKCTRL_PDIV_10X_gc);
    _PROTECTED_WRITE(CLKCTRL.MCLKCTRLA, CLKCTRL_CLKOUT_bm);

    // start Xtal oscillators
    _PROTECTED_WRITE(CLKCTRL.XOSC32KCTRLA, CLKCTRL_ENABLE_bm | CLKCTRL_RUNSTBY_bm | CLKCTRL_LPMODE_bm | CLKCTRL_CSUT_1K_gc);
    //_PROTECTED_WRITE(CLKCTRL.XOSCHFCTRLA, CLKCTRL_ENABLE_bm | CLKCTRL_RUNSTBY_bm | CLKCTRL_FRQRANGE_16M_gc | CLKCTRL_CSUTHF_4K_gc);

    _delay_ms(10);

    _PROTECTED_WRITE(CLKCTRL.MCLKCTRLA, /*CLKCTRL_CLKOUT_bm |*/ CLKCTRL_CLKSEL_XOSC32K_gc);


    if (CLKCTRL.MCLKSTATUS & CLKCTRL_EXTS_bm) { // 16MHz xtal is running
        //_PROTECTED_WRITE(CLKCTRL.MCLKCTRLC, CLKCTRL_CFD_bm | CLKCTRL_CFDSRC_CLKMAIN_gc);
        //_PROTECTED_WRITE(CLKCTRL.MCLKCTRLA, /*CLKCTRL_CLKOUT_bm |*/ CLKCTRL_CLKSEL_EXTCLK_gc);
    }

    RTC.CLKSEL = RTC_CLKSEL_XOSC32K_gc;
    RTC.CTRLA = RTC_RUNSTDBY_bm | RTC_PRESCALER_DIV32768_gc | RTC_RTCEN_bm;
    RTC.DBGCTRL = RTC_DBGRUN_bm;

    RTC.PITCTRLA = RTC_PITEN_bm | RTC_PERIOD_CYC32768_gc;
    RTC.PITDBGCTRL = RTC_DBGRUN_bm;


    PORTA.PIN0CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTA.PIN1CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTA.PIN2CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTA.PIN3CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTA.PIN4CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTA.PIN5CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTA.PIN6CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTA.PIN7CTRL = PORT_ISC_INPUT_DISABLE_gc;

    PORTB.PIN0CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTB.PIN1CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTB.PIN2CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTB.PIN3CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTB.PIN4CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTB.PIN5CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTB.PIN6CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTB.PIN7CTRL = PORT_ISC_INPUT_DISABLE_gc;

    PORTC.PIN0CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTC.PIN1CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTC.PIN2CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTC.PIN3CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTC.PIN4CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTC.PIN5CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTC.PIN6CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTC.PIN7CTRL = PORT_ISC_INPUT_DISABLE_gc;

    PORTD.PIN0CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTD.PIN1CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTD.PIN2CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTD.PIN3CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTD.PIN4CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTD.PIN5CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTD.PIN6CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTD.PIN7CTRL = PORT_ISC_INPUT_DISABLE_gc;

    PORTE.PIN0CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTE.PIN1CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTE.PIN2CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTE.PIN3CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTE.PIN4CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTE.PIN5CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTE.PIN6CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTE.PIN7CTRL = PORT_ISC_INPUT_DISABLE_gc;

    PORTF.PIN0CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTF.PIN1CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTF.PIN2CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTF.PIN3CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTF.PIN4CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTF.PIN5CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTF.PIN6CTRL = PORT_ISC_INPUT_DISABLE_gc;
    PORTF.PIN7CTRL = PORT_ISC_INPUT_DISABLE_gc;


    PORTB.DIRSET = PIN3_bm; // PB3 onboard led
    PORTB.OUTSET = PIN3_bm;

    //VREF.DAC0REF = VREF_ALWAYSON_bm | VREF_REFSEL_2V500_gc;

    //DAC0.CTRLA = DAC_OUTEN_bm | DAC_ENABLE_bm;
    //DAC0.DATA = 512u << 6;

    while (1) {
        if (RTC.PITINTFLAGS & RTC_PI_bm) {
            RTC.PITINTFLAGS = RTC_PI_bm;
            //VPORTB.IN = PIN3_bm;
            
            inc3(reset_counter);
        }

        //VPORTB.IN = PIN3_bm;
        //_delay_ms(500);
    }
}

